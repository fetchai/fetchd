syntax = "proto3";

package fetchai.group.v1alpha1;

option go_package = "github.com/fetchai/fetchd/x/group";

import "gogoproto/gogo.proto";
import "cosmos_proto/cosmos.proto";
import "google/protobuf/any.proto";
import "google/protobuf/timestamp.proto";
import "fetchai/group/v1alpha1/types.proto";

// Msg is the fetchai.group.v1alpha1 Msg service.
service Msg {

    // CreateGroup creates a new group with an admin account address, a list of members and some optional metadata.
    rpc CreateGroup(MsgCreateGroup) returns (MsgCreateGroupResponse);

    // UpdateGroupMembers updates the group members with given group id and admin address.
    rpc UpdateGroupMembers(MsgUpdateGroupMembers) returns (MsgUpdateGroupMembersResponse);

    // UpdateGroupAdmin updates the group admin with given group id and previous admin address.
    rpc UpdateGroupAdmin(MsgUpdateGroupAdmin) returns (MsgUpdateGroupAdminResponse);

    // UpdateGroupMetadata updates the group metadata with given group id and admin address.
    rpc UpdateGroupMetadata(MsgUpdateGroupMetadata) returns (MsgUpdateGroupMetadataResponse);

    // CreateGroupAccount creates a new group account using given DecisionPolicy. 
    rpc CreateGroupAccount(MsgCreateGroupAccount) returns (MsgCreateGroupAccountResponse);

    // UpdateGroupAccountAdmin updates a group account admin. 
    rpc UpdateGroupAccountAdmin(MsgUpdateGroupAccountAdmin) returns (MsgUpdateGroupAccountAdminResponse);

    // UpdateGroupAccountDecisionPolicy allows a group account decision policy to be updated.
    rpc UpdateGroupAccountDecisionPolicy(MsgUpdateGroupAccountDecisionPolicy) returns (MsgUpdateGroupAccountDecisionPolicyResponse);

    // UpdateGroupAccountMetadata updates a group account metadata.
    rpc UpdateGroupAccountMetadata(MsgUpdateGroupAccountMetadata) returns (MsgUpdateGroupAccountMetadataResponse);

    // CreateProposal submits a new proposal.
    rpc CreateProposal(MsgCreateProposal) returns (MsgCreateProposalResponse);

    // Vote allows a voter to vote on a proposal.
    rpc Vote(MsgVote) returns (MsgVoteResponse);

    // VoteAgg allows a sender to submit a set of votes
    rpc VoteAgg(MsgVoteAgg)  returns (MsgVoteAggResponse);

    // Exec executes a proposal.
    rpc Exec(MsgExec) returns (MsgExecResponse);

    // CreatePoll submits a new poll.
    rpc CreatePoll(MsgCreatePoll) returns (MsgCreatePollResponse);

    // VotePoll allows a voter to vote on a poll.
    rpc VotePoll(MsgVotePoll) returns (MsgVotePollResponse);

    // VotePollAgg allows a sender to submit a set of votes
    rpc VotePollAgg(MsgVotePollAgg)  returns (MsgVotePollAggResponse);
}

//
// Groups
//

// MsgCreateGroup is the Msg/CreateGroup request type.
message MsgCreateGroup {

    // admin is the account address of the group admin.
    string admin = 1;
    
    // members defines the group members.
    repeated Member members = 2 [(gogoproto.nullable) = false];
    
    // metadata is any arbitrary metadata to attached to the group.
    bytes metadata = 3;

    // bls_only requires all the group members to use bls public keys so their votes can be aggregated together
    bool bls_only = 4;
}

// MsgCreateGroupResponse is the Msg/CreateGroup response type.
message MsgCreateGroupResponse {

    // group_id is the unique ID of the newly created group.
    uint64 group_id = 1;
}

// MsgUpdateGroupMembers is the Msg/UpdateGroupMembers request type.
message MsgUpdateGroupMembers {

    // admin is the account address of the group admin.
    string admin = 1;
    
    // group_id is the unique ID of the group.
    uint64 group_id = 2;
    
    // member_updates is the list of members to update,
    // set weight to 0 to remove a member.
    repeated Member member_updates = 3 [(gogoproto.nullable) = false];
}

// MsgUpdateGroupMembersResponse is the Msg/UpdateGroupMembers response type.
message MsgUpdateGroupMembersResponse { }

// MsgUpdateGroupAdmin is the Msg/UpdateGroupAdmin request type.
message MsgUpdateGroupAdmin {

    // admin is the current account address of the group admin.
    string admin = 1;
    
    // group_id is the unique ID of the group.
    uint64 group_id = 2;
   
    // new_admin is the group new admin account address.
    string new_admin = 3;
}

// MsgUpdateGroupAdminResponse is the Msg/UpdateGroupAdmin response type.
message MsgUpdateGroupAdminResponse { }

// MsgUpdateGroupMetadata is the Msg/UpdateGroupMetadata request type.
message MsgUpdateGroupMetadata {

    // admin is the account address of the group admin.
    string admin = 1;
    
    // group_id is the unique ID of the group.
    uint64 group_id = 2;
    
    // metadata is the updated group's metadata.
    bytes metadata = 3;
}

// MsgUpdateGroupMetadataResponse is the Msg/UpdateGroupMetadata response type.
message MsgUpdateGroupMetadataResponse { }

//
// Group Accounts
//

// MsgCreateGroupAccount is the Msg/CreateGroupAccount request type.
message MsgCreateGroupAccount {
    option (gogoproto.goproto_getters) = false;

    // admin is the account address of the group admin.
    string admin = 1;
    
    // group_id is the unique ID of the group.
    uint64 group_id = 2;
    
    // metadata is any arbitrary metadata to attached to the group account.
    bytes metadata = 3;

    // decision_policy specifies the group account's decision policy.
    google.protobuf.Any decision_policy = 4 [(cosmos_proto.accepts_interface) = "DecisionPolicy"];
}

// MsgCreateGroupAccountResponse is the Msg/CreateGroupAccount response type.
message MsgCreateGroupAccountResponse {

    // address is the account address of the newly created group account.
    string address = 1;
}

// MsgUpdateGroupAccountAdmin is the Msg/UpdateGroupAccountAdmin request type.
message MsgUpdateGroupAccountAdmin {

    // admin is the account address of the group admin.
    string admin = 1;
    
    // address is the group account address.
    string address = 2;
    
    // new_admin is the new group account admin.
    string new_admin = 3;
}

// MsgUpdateGroupAccountAdminResponse is the Msg/UpdateGroupAccountAdmin response type.
message MsgUpdateGroupAccountAdminResponse { }

// MsgUpdateGroupAccountDecisionPolicy is the Msg/UpdateGroupAccountDecisionPolicy request type.
message MsgUpdateGroupAccountDecisionPolicy {
    option (gogoproto.goproto_getters) = false;

    // admin is the account address of the group admin.
    string admin = 1;
    
    // address is the group account address.
    string address = 2;
    
    // decision_policy is the updated group account decision policy.
    google.protobuf.Any decision_policy = 3 [(cosmos_proto.accepts_interface) = "DecisionPolicy"];
}

// MsgUpdateGroupAccountDecisionPolicyResponse is the Msg/UpdateGroupAccountDecisionPolicy response type.
message MsgUpdateGroupAccountDecisionPolicyResponse { }

// MsgUpdateGroupAccountMetadata is the Msg/UpdateGroupAccountMetadata request type.
message MsgUpdateGroupAccountMetadata {

    // admin is the account address of the group admin.
    string admin = 1;
    
    // address is the group account address.
    string address = 2;
    
    // metadata is the updated group account metadata.
    bytes metadata = 3;
}

// MsgUpdateGroupAccountMetadataResponse is the Msg/UpdateGroupAccountMetadata response type.
message MsgUpdateGroupAccountMetadataResponse { }

//
// Proposals and Voting
//

// Exec defines modes of execution of a proposal on creation or on new vote.
enum Exec {

    // An empty value means that there should be a separate 
    // MsgExec request for the proposal to execute.
    EXEC_UNSPECIFIED = 0;

    // Try to execute the proposal immediately.
    // If the proposal is not allowed per the DecisionPolicy,
    // the proposal will still be open and could 
    // be executed at a later point.
    EXEC_TRY = 1;
}

// MsgCreateProposal is the Msg/CreateProposal request type.
message MsgCreateProposal {
    option (gogoproto.goproto_getters) = false;

    // address is the group account address.
    string address = 1;
    
    // proposers are the account addresses of the proposers.
    // Proposers signatures will be counted as yes votes.
    repeated string proposers = 2;
    
    // metadata is any arbitrary metadata to attached to the proposal.
    bytes metadata = 3;

    // msgs is a list of Msgs that will be executed if the proposal passes.
    repeated google.protobuf.Any msgs = 4;

    // exec defines the mode of execution of the proposal,
    // whether it should be executed immediately on creation or not.
    // If so, proposers signatures are considered as Yes votes.
    Exec exec = 5;
}

// MsgCreateProposalResponse is the Msg/CreateProposal response type.
message MsgCreateProposalResponse {

    // proposal is the unique ID of the proposal.
    uint64 proposal_id = 1;
}

// MsgVote is the Msg/Vote request type.
message MsgVote {

    // proposal is the unique ID of the proposal.
    uint64 proposal_id = 1;
    
    // voter is the voter account address.
    string voter = 2;
    
    // choice is the voter's choice on the proposal.
    Choice choice = 3;

    // metadata is any arbitrary metadata to attached to the vote.
    bytes metadata = 4;

    // exec defines whether the proposal should be executed
    // immediately after voting or not.
    Exec exec = 5;
}

// MsgVoteResponse is the Msg/Vote response type.
message MsgVoteResponse { }


// MsgVoteBasicRequest is the Msg/Vote request type.
message MsgVoteBasic {

    // proposal is the unique ID of the proposal.
    uint64 proposal_id = 1;

    // choice is the voter's choice on the proposal.
    Choice choice = 2;

    // expiry is the timestamp after which the basic vote expires.
    google.protobuf.Timestamp expiry = 3 [(gogoproto.nullable) = false];
}

// MsgVoteResponse is the basic vote that can be aggregated together
message MsgVoteBasicResponse {
    // proposal is the unique ID of the proposal.
    uint64 proposal_id = 1;

    // choice is the voter's choice on the proposal.
    Choice choice = 2;

    // expiry is the timestamp after which the basic vote expires.
    google.protobuf.Timestamp expiry = 3 [(gogoproto.nullable) = false];

    // voter is the account address of the voter.
    string voter = 4;

    // pub_key is the voter's public key
    google.protobuf.Any pub_key = 5
    [(gogoproto.jsontag) = "public_key,omitempty", (gogoproto.moretags) = "yaml:\"public_key\""];

    // sig is the individual signature which will be aggregated with other signatures
    bytes sig = 6;
}

// MsgVoteAgg is the Msg/VoteAgg request type.
message MsgVoteAgg {
    // sender is the person who submits the votes
    string sender = 1;

    // proposal is the unique ID of the proposal.
    uint64 proposal_id = 2;

    // votes are the list of voters' choices on the proposal.
    repeated Choice votes = 3;

    // expiry is the timestamp after which the basic vote expires.
    // All the basic votes to be aggregated must have the same expiry.
    // Expiry should be set to be before the proposal timeout in order to
    // prevent replay attacks and also prevent the aggregator from removing
    // some basic votes.
    google.protobuf.Timestamp expiry = 4 [(gogoproto.nullable) = false];

    // agg_sig is the bls aggregated signature for all the votes
    bytes agg_sig = 5;

    // metadata is any arbitrary metadata attached to the vote.
    bytes metadata = 6;

    // exec defines whether the proposal should be executed
    // immediately after voting or not.
    Exec exec = 7;
}

// MsgVoteResponse is the Msg/Vote response type.
message MsgVoteAggResponse { }

// MsgExec is the Msg/Exec request type.
message MsgExec {

    // proposal is the unique ID of the proposal.
    uint64 proposal_id = 1;
    
    // signer is the account address used to execute the proposal.
    string signer = 2;
}

// MsgExecResponse is the Msg/Exec request type.
message MsgExecResponse { }



// MsgCreateProposal is the Msg/CreateProposal request type.
message MsgCreatePoll {
    option (gogoproto.goproto_getters) = false;

    // group_id is the unique ID of the group.
    uint64 group_id = 1;

    string title = 2;

    Options options = 3 [(gogoproto.nullable) = false];;

    string creator = 4;

    // vote_limit is the number of options each voter can choose.
    int32 vote_limit = 5;

    // metadata is any arbitrary metadata to attached to the proposal.
    bytes metadata = 6;

    // timeout is the deadline of the poll.
    google.protobuf.Timestamp timeout = 7 [(gogoproto.nullable) = false];
}

// MsgCreateProposalResponse is the Msg/CreateProposal response type.
message MsgCreatePollResponse {

    // poll_id is the unique ID of the poll.
    uint64 poll_id = 1;
}

// MsgVotePoll is the Msg/VotePoll request type.
message MsgVotePoll {

    // poll_id is the unique ID of the poll.
    uint64 poll_id = 1;

    // voter is the voter account address.
    string voter = 2;

    // options are the voter's choices on the poll.
    Options options = 3 [(gogoproto.nullable) = false];

    // metadata is any arbitrary metadata to attached to the vote.
    bytes metadata = 4;
}

// MsgVotePollResponse is the Msg/VotePoll response type.
message MsgVotePollResponse { }

// MsgVoteBasicRequest is the Msg/Vote request type.
message MsgVotePollBasic {

    // poll_id is the unique ID of the poll.
    uint64 poll_id = 1;

    // option is one of the voter's choices on the poll.
    string option = 2;

    // expiry is the unique timestamp after which the basic vote expires.
    google.protobuf.Timestamp expiry = 3 [(gogoproto.nullable) = false];
}

// MsgVoteResponse is the basic vote that can be aggregated together
message MsgVotePollBasicResponse {
    // proposal is the unique ID of the proposal.
    uint64 poll_id = 1;

    // options are the voter's choices on the poll.
    Options options = 2 [(gogoproto.nullable) = false];

    // expiry is the timestamp after which the basic vote expires.
    google.protobuf.Timestamp expiry = 3 [(gogoproto.nullable) = false];

    // voter is the account address of the voter.
    string voter = 4;

    // pub_key is the voter's public key
    google.protobuf.Any pub_key = 5
    [(gogoproto.jsontag) = "public_key,omitempty", (gogoproto.moretags) = "yaml:\"public_key\""];

    // sig is the individual signature which will be aggregated with other voters' signatures
    bytes sig = 6;
}

// MsgVoteAgg is the Msg/VoteAgg request type.
message MsgVotePollAgg {
    // sender is the person who submits the votes
    string sender = 1;

    // poll_id is the unique ID of the poll.
    uint64 poll_id = 2;

    // votes are the full list of voters' choices on the proposal.
    repeated Options votes = 3 [(gogoproto.nullable) = false];

    // expiry is the timestamp after which the basic vote expires.
    // All the basic votes to be aggregated must have the same expiry.
    // Expiry should be set to be before the poll timeout in order to
    // prevent replay attacks and also prevent the aggregator from removing
    // some basic votes.
    google.protobuf.Timestamp expiry = 4 [(gogoproto.nullable) = false];

    // agg_sig is the bls aggregated signature for all the votes
    bytes agg_sig = 5;

    // metadata is any arbitrary metadata to attached to the vote.
    bytes metadata = 6;
}

// MsgVoteResponse is the Msg/Vote response type.
message MsgVotePollAggResponse { }