// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: fetchai/group/v1alpha1/types.proto

package group

import (
	bytes "bytes"
	fmt "fmt"
	types1 "github.com/cosmos/cosmos-sdk/codec/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	_ "github.com/regen-network/cosmos-proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Choice defines available types of choices for voting.
type Choice int32

const (
	// CHOICE_UNSPECIFIED defines a no-op voting choice.
	Choice_CHOICE_UNSPECIFIED Choice = 0
	// CHOICE_NO defines a no voting choice.
	Choice_CHOICE_NO Choice = 1
	// CHOICE_YES defines a yes voting choice.
	Choice_CHOICE_YES Choice = 2
	// CHOICE_ABSTAIN defines an abstaining voting choice.
	Choice_CHOICE_ABSTAIN Choice = 3
	// CHOICE_VETO defines a voting choice with veto.
	Choice_CHOICE_VETO Choice = 4
)

var Choice_name = map[int32]string{
	0: "CHOICE_UNSPECIFIED",
	1: "CHOICE_NO",
	2: "CHOICE_YES",
	3: "CHOICE_ABSTAIN",
	4: "CHOICE_VETO",
}

var Choice_value = map[string]int32{
	"CHOICE_UNSPECIFIED": 0,
	"CHOICE_NO":          1,
	"CHOICE_YES":         2,
	"CHOICE_ABSTAIN":     3,
	"CHOICE_VETO":        4,
}

func (x Choice) String() string {
	return proto.EnumName(Choice_name, int32(x))
}

func (Choice) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_35b2f87fd83fcfeb, []int{0}
}

// Status defines proposal statuses.
type Proposal_Status int32

const (
	// An empty value is invalid and not allowed.
	ProposalStatusInvalid Proposal_Status = 0
	// Initial status of a proposal when persisted.
	ProposalStatusSubmitted Proposal_Status = 1
	// Final status of a proposal when the final tally was executed.
	ProposalStatusClosed Proposal_Status = 2
	// Final status of a proposal when the group was modified before the final tally.
	ProposalStatusAborted Proposal_Status = 3
)

var Proposal_Status_name = map[int32]string{
	0: "STATUS_UNSPECIFIED",
	1: "STATUS_SUBMITTED",
	2: "STATUS_CLOSED",
	3: "STATUS_ABORTED",
}

var Proposal_Status_value = map[string]int32{
	"STATUS_UNSPECIFIED": 0,
	"STATUS_SUBMITTED":   1,
	"STATUS_CLOSED":      2,
	"STATUS_ABORTED":     3,
}

func (x Proposal_Status) String() string {
	return proto.EnumName(Proposal_Status_name, int32(x))
}

func (Proposal_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_35b2f87fd83fcfeb, []int{6, 0}
}

// Result defines types of proposal results.
type Proposal_Result int32

const (
	// An empty value is invalid and not allowed
	ProposalResultInvalid Proposal_Result = 0
	// Until a final tally has happened the status is unfinalized
	ProposalResultUnfinalized Proposal_Result = 1
	// Final result of the tally
	ProposalResultAccepted Proposal_Result = 2
	// Final result of the tally
	ProposalResultRejected Proposal_Result = 3
)

var Proposal_Result_name = map[int32]string{
	0: "RESULT_UNSPECIFIED",
	1: "RESULT_UNFINALIZED",
	2: "RESULT_ACCEPTED",
	3: "RESULT_REJECTED",
}

var Proposal_Result_value = map[string]int32{
	"RESULT_UNSPECIFIED": 0,
	"RESULT_UNFINALIZED": 1,
	"RESULT_ACCEPTED":    2,
	"RESULT_REJECTED":    3,
}

func (x Proposal_Result) String() string {
	return proto.EnumName(Proposal_Result_name, int32(x))
}

func (Proposal_Result) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_35b2f87fd83fcfeb, []int{6, 1}
}

// ExecutorResult defines types of proposal executor results.
type Proposal_ExecutorResult int32

const (
	// An empty value is not allowed.
	ProposalExecutorResultInvalid Proposal_ExecutorResult = 0
	// We have not yet run the executor.
	ProposalExecutorResultNotRun Proposal_ExecutorResult = 1
	// The executor was successful and proposed action updated state.
	ProposalExecutorResultSuccess Proposal_ExecutorResult = 2
	// The executor returned an error and proposed action didn't update state.
	ProposalExecutorResultFailure Proposal_ExecutorResult = 3
)

var Proposal_ExecutorResult_name = map[int32]string{
	0: "EXECUTOR_RESULT_UNSPECIFIED",
	1: "EXECUTOR_RESULT_NOT_RUN",
	2: "EXECUTOR_RESULT_SUCCESS",
	3: "EXECUTOR_RESULT_FAILURE",
}

var Proposal_ExecutorResult_value = map[string]int32{
	"EXECUTOR_RESULT_UNSPECIFIED": 0,
	"EXECUTOR_RESULT_NOT_RUN":     1,
	"EXECUTOR_RESULT_SUCCESS":     2,
	"EXECUTOR_RESULT_FAILURE":     3,
}

func (x Proposal_ExecutorResult) String() string {
	return proto.EnumName(Proposal_ExecutorResult_name, int32(x))
}

func (Proposal_ExecutorResult) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_35b2f87fd83fcfeb, []int{6, 2}
}

// Status defines poll statuses.
type Poll_Status int32

const (
	// An empty value is invalid and not allowed.
	PollStatusInvalid Poll_Status = 0
	// Initial status of a poll when persisted.
	PollStatusSubmitted Poll_Status = 1
	// Final status of a poll when the final tally was executed.
	PollStatusClosed Poll_Status = 2
	// Final status of a poll when the group was modified before the final tally.
	PollStatusAborted Poll_Status = 3
)

var Poll_Status_name = map[int32]string{
	0: "STATUS_UNSPECIFIED",
	1: "STATUS_SUBMITTED",
	2: "STATUS_CLOSED",
	3: "STATUS_ABORTED",
}

var Poll_Status_value = map[string]int32{
	"STATUS_UNSPECIFIED": 0,
	"STATUS_SUBMITTED":   1,
	"STATUS_CLOSED":      2,
	"STATUS_ABORTED":     3,
}

func (x Poll_Status) String() string {
	return proto.EnumName(Poll_Status_name, int32(x))
}

func (Poll_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_35b2f87fd83fcfeb, []int{12, 0}
}

// Member represents a group member with an account address,
// non-zero weight and metadata.
type Member struct {
	// address is the member's account address.
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// weight is the member's voting weight that should be greater than 0.
	Weight string `protobuf:"bytes,2,opt,name=weight,proto3" json:"weight,omitempty"`
	// metadata is any arbitrary metadata to attached to the member.
	Metadata []byte `protobuf:"bytes,3,opt,name=metadata,proto3" json:"metadata,omitempty"`
}

func (m *Member) Reset()         { *m = Member{} }
func (m *Member) String() string { return proto.CompactTextString(m) }
func (*Member) ProtoMessage()    {}
func (*Member) Descriptor() ([]byte, []int) {
	return fileDescriptor_35b2f87fd83fcfeb, []int{0}
}
func (m *Member) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Member) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Member.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Member) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Member.Merge(m, src)
}
func (m *Member) XXX_Size() int {
	return m.Size()
}
func (m *Member) XXX_DiscardUnknown() {
	xxx_messageInfo_Member.DiscardUnknown(m)
}

var xxx_messageInfo_Member proto.InternalMessageInfo

func (m *Member) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Member) GetWeight() string {
	if m != nil {
		return m.Weight
	}
	return ""
}

func (m *Member) GetMetadata() []byte {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// Members defines a repeated slice of Member objects.
type Members struct {
	// members is the list of members.
	Members []Member `protobuf:"bytes,1,rep,name=members,proto3" json:"members"`
}

func (m *Members) Reset()         { *m = Members{} }
func (m *Members) String() string { return proto.CompactTextString(m) }
func (*Members) ProtoMessage()    {}
func (*Members) Descriptor() ([]byte, []int) {
	return fileDescriptor_35b2f87fd83fcfeb, []int{1}
}
func (m *Members) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Members) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Members.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Members) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Members.Merge(m, src)
}
func (m *Members) XXX_Size() int {
	return m.Size()
}
func (m *Members) XXX_DiscardUnknown() {
	xxx_messageInfo_Members.DiscardUnknown(m)
}

var xxx_messageInfo_Members proto.InternalMessageInfo

func (m *Members) GetMembers() []Member {
	if m != nil {
		return m.Members
	}
	return nil
}

// ThresholdDecisionPolicy implements the DecisionPolicy interface
type ThresholdDecisionPolicy struct {
	// threshold is the minimum weighted sum of yes votes that must be met or exceeded for a proposal to succeed.
	Threshold string `protobuf:"bytes,1,opt,name=threshold,proto3" json:"threshold,omitempty"`
	// timeout is the duration from submission of a proposal to the end of voting period
	// Within this times votes and exec messages can be submitted.
	Timeout types.Duration `protobuf:"bytes,2,opt,name=timeout,proto3" json:"timeout"`
}

func (m *ThresholdDecisionPolicy) Reset()         { *m = ThresholdDecisionPolicy{} }
func (m *ThresholdDecisionPolicy) String() string { return proto.CompactTextString(m) }
func (*ThresholdDecisionPolicy) ProtoMessage()    {}
func (*ThresholdDecisionPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_35b2f87fd83fcfeb, []int{2}
}
func (m *ThresholdDecisionPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ThresholdDecisionPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ThresholdDecisionPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ThresholdDecisionPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ThresholdDecisionPolicy.Merge(m, src)
}
func (m *ThresholdDecisionPolicy) XXX_Size() int {
	return m.Size()
}
func (m *ThresholdDecisionPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_ThresholdDecisionPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_ThresholdDecisionPolicy proto.InternalMessageInfo

func (m *ThresholdDecisionPolicy) GetThreshold() string {
	if m != nil {
		return m.Threshold
	}
	return ""
}

func (m *ThresholdDecisionPolicy) GetTimeout() types.Duration {
	if m != nil {
		return m.Timeout
	}
	return types.Duration{}
}

// GroupInfo represents the high-level on-chain information for a group.
type GroupInfo struct {
	// group_id is the unique ID of the group.
	GroupId uint64 `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	// admin is the account address of the group's admin.
	Admin string `protobuf:"bytes,2,opt,name=admin,proto3" json:"admin,omitempty"`
	// metadata is any arbitrary metadata to attached to the group.
	Metadata []byte `protobuf:"bytes,3,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// version is used to track changes to a group's membership structure that
	// would break existing proposals. Whenever any members weight is changed,
	// or any member is added or removed this version is incremented and will
	// cause proposals based on older versions of this group to fail
	Version uint64 `protobuf:"varint,4,opt,name=version,proto3" json:"version,omitempty"`
	// total_weight is the sum of the group members' weights.
	TotalWeight string `protobuf:"bytes,5,opt,name=total_weight,json=totalWeight,proto3" json:"total_weight,omitempty"`
	// bls_only requires all the group members to use bls public keys so their votes can be aggregated together
	BlsOnly bool `protobuf:"varint,6,opt,name=bls_only,json=blsOnly,proto3" json:"bls_only,omitempty"`
}

func (m *GroupInfo) Reset()         { *m = GroupInfo{} }
func (m *GroupInfo) String() string { return proto.CompactTextString(m) }
func (*GroupInfo) ProtoMessage()    {}
func (*GroupInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_35b2f87fd83fcfeb, []int{3}
}
func (m *GroupInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupInfo.Merge(m, src)
}
func (m *GroupInfo) XXX_Size() int {
	return m.Size()
}
func (m *GroupInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GroupInfo proto.InternalMessageInfo

func (m *GroupInfo) GetGroupId() uint64 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *GroupInfo) GetAdmin() string {
	if m != nil {
		return m.Admin
	}
	return ""
}

func (m *GroupInfo) GetMetadata() []byte {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *GroupInfo) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *GroupInfo) GetTotalWeight() string {
	if m != nil {
		return m.TotalWeight
	}
	return ""
}

func (m *GroupInfo) GetBlsOnly() bool {
	if m != nil {
		return m.BlsOnly
	}
	return false
}

// GroupMember represents the relationship between a group and a member.
type GroupMember struct {
	// group_id is the unique ID of the group.
	GroupId uint64 `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	// member is the member data.
	Member *Member `protobuf:"bytes,2,opt,name=member,proto3" json:"member,omitempty"`
}

func (m *GroupMember) Reset()         { *m = GroupMember{} }
func (m *GroupMember) String() string { return proto.CompactTextString(m) }
func (*GroupMember) ProtoMessage()    {}
func (*GroupMember) Descriptor() ([]byte, []int) {
	return fileDescriptor_35b2f87fd83fcfeb, []int{4}
}
func (m *GroupMember) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupMember) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupMember.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupMember) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupMember.Merge(m, src)
}
func (m *GroupMember) XXX_Size() int {
	return m.Size()
}
func (m *GroupMember) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupMember.DiscardUnknown(m)
}

var xxx_messageInfo_GroupMember proto.InternalMessageInfo

func (m *GroupMember) GetGroupId() uint64 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *GroupMember) GetMember() *Member {
	if m != nil {
		return m.Member
	}
	return nil
}

// GroupAccountInfo represents the high-level on-chain information for a group account.
type GroupAccountInfo struct {
	// address is the group account address.
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// group_id is the unique ID of the group.
	GroupId uint64 `protobuf:"varint,2,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	// admin is the account address of the group admin.
	Admin string `protobuf:"bytes,3,opt,name=admin,proto3" json:"admin,omitempty"`
	// metadata is any arbitrary metadata to attached to the group account.
	Metadata []byte `protobuf:"bytes,4,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// version is used to track changes to a group's GroupAccountInfo structure that
	// would create a different result on a running proposal.
	Version uint64 `protobuf:"varint,5,opt,name=version,proto3" json:"version,omitempty"`
	// decision_policy specifies the group account's decision policy.
	DecisionPolicy *types1.Any `protobuf:"bytes,6,opt,name=decision_policy,json=decisionPolicy,proto3" json:"decision_policy,omitempty"`
	// derivation_key is the "derivation" key of the group account,
	// which is needed to derive the group root module key and execute proposals.
	DerivationKey []byte `protobuf:"bytes,7,opt,name=derivation_key,json=derivationKey,proto3" json:"derivation_key,omitempty"`
}

func (m *GroupAccountInfo) Reset()         { *m = GroupAccountInfo{} }
func (m *GroupAccountInfo) String() string { return proto.CompactTextString(m) }
func (*GroupAccountInfo) ProtoMessage()    {}
func (*GroupAccountInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_35b2f87fd83fcfeb, []int{5}
}
func (m *GroupAccountInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupAccountInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupAccountInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupAccountInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupAccountInfo.Merge(m, src)
}
func (m *GroupAccountInfo) XXX_Size() int {
	return m.Size()
}
func (m *GroupAccountInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupAccountInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GroupAccountInfo proto.InternalMessageInfo

// Proposal defines a group proposal. Any member of a group can submit a proposal
// for a group account to decide upon.
// A proposal consists of a set of `sdk.Msg`s that will be executed if the proposal
// passes as well as some optional metadata associated with the proposal.
type Proposal struct {
	// proposal_id is the unique id of the proposal.
	ProposalId uint64 `protobuf:"varint,1,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
	// address is the group account address.
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	// metadata is any arbitrary metadata to attached to the proposal.
	Metadata []byte `protobuf:"bytes,3,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// proposers are the account addresses of the proposers.
	Proposers []string `protobuf:"bytes,4,rep,name=proposers,proto3" json:"proposers,omitempty"`
	// submitted_at is a timestamp specifying when a proposal was submitted.
	SubmittedAt types.Timestamp `protobuf:"bytes,5,opt,name=submitted_at,json=submittedAt,proto3" json:"submitted_at"`
	// group_version tracks the version of the group that this proposal corresponds to.
	// When group membership is changed, existing proposals from previous group versions will become invalid.
	GroupVersion uint64 `protobuf:"varint,6,opt,name=group_version,json=groupVersion,proto3" json:"group_version,omitempty"`
	// group_account_version tracks the version of the group account that this proposal corresponds to.
	// When a decision policy is changed, existing proposals from previous policy versions will become invalid.
	GroupAccountVersion uint64 `protobuf:"varint,7,opt,name=group_account_version,json=groupAccountVersion,proto3" json:"group_account_version,omitempty"`
	// Status represents the high level position in the life cycle of the proposal. Initial value is Submitted.
	Status Proposal_Status `protobuf:"varint,8,opt,name=status,proto3,enum=fetchai.group.v1alpha1.Proposal_Status" json:"status,omitempty"`
	// result is the final result based on the votes and election rule. Initial value is unfinalized.
	// The result is persisted so that clients can always rely on this state and not have to replicate the logic.
	Result Proposal_Result `protobuf:"varint,9,opt,name=result,proto3,enum=fetchai.group.v1alpha1.Proposal_Result" json:"result,omitempty"`
	// vote_state contains the sums of all weighted votes for this proposal.
	VoteState Tally `protobuf:"bytes,10,opt,name=vote_state,json=voteState,proto3" json:"vote_state"`
	// timeout is the timestamp of the block where the proposal execution times out. Header times of the votes and execution messages
	// must be before this end time to be included in the election. After the timeout timestamp the proposal can not be
	// executed anymore and should be considered pending delete.
	Timeout types.Timestamp `protobuf:"bytes,11,opt,name=timeout,proto3" json:"timeout"`
	// executor_result is the final result based on the votes and election rule. Initial value is NotRun.
	ExecutorResult Proposal_ExecutorResult `protobuf:"varint,12,opt,name=executor_result,json=executorResult,proto3,enum=fetchai.group.v1alpha1.Proposal_ExecutorResult" json:"executor_result,omitempty"`
	// msgs is a list of Msgs that will be executed if the proposal passes.
	Msgs []*types1.Any `protobuf:"bytes,13,rep,name=msgs,proto3" json:"msgs,omitempty"`
}

func (m *Proposal) Reset()         { *m = Proposal{} }
func (m *Proposal) String() string { return proto.CompactTextString(m) }
func (*Proposal) ProtoMessage()    {}
func (*Proposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_35b2f87fd83fcfeb, []int{6}
}
func (m *Proposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Proposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Proposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Proposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Proposal.Merge(m, src)
}
func (m *Proposal) XXX_Size() int {
	return m.Size()
}
func (m *Proposal) XXX_DiscardUnknown() {
	xxx_messageInfo_Proposal.DiscardUnknown(m)
}

var xxx_messageInfo_Proposal proto.InternalMessageInfo

// Tally represents the sum of weighted votes.
type Tally struct {
	// yes_count is the weighted sum of yes votes.
	YesCount string `protobuf:"bytes,1,opt,name=yes_count,json=yesCount,proto3" json:"yes_count,omitempty"`
	// no_count is the weighted sum of no votes.
	NoCount string `protobuf:"bytes,2,opt,name=no_count,json=noCount,proto3" json:"no_count,omitempty"`
	// abstain_count is the weighted sum of abstainers
	AbstainCount string `protobuf:"bytes,3,opt,name=abstain_count,json=abstainCount,proto3" json:"abstain_count,omitempty"`
	// veto_count is the weighted sum of vetoes.
	VetoCount string `protobuf:"bytes,4,opt,name=veto_count,json=vetoCount,proto3" json:"veto_count,omitempty"`
}

func (m *Tally) Reset()         { *m = Tally{} }
func (m *Tally) String() string { return proto.CompactTextString(m) }
func (*Tally) ProtoMessage()    {}
func (*Tally) Descriptor() ([]byte, []int) {
	return fileDescriptor_35b2f87fd83fcfeb, []int{7}
}
func (m *Tally) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tally) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tally.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tally) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tally.Merge(m, src)
}
func (m *Tally) XXX_Size() int {
	return m.Size()
}
func (m *Tally) XXX_DiscardUnknown() {
	xxx_messageInfo_Tally.DiscardUnknown(m)
}

var xxx_messageInfo_Tally proto.InternalMessageInfo

// Vote represents a vote for a proposal.
type Vote struct {
	// proposal is the unique ID of the proposal.
	ProposalId uint64 `protobuf:"varint,1,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
	// voter is the account address of the voter.
	Voter string `protobuf:"bytes,2,opt,name=voter,proto3" json:"voter,omitempty"`
	// choice is the voter's choice on the proposal.
	Choice Choice `protobuf:"varint,3,opt,name=choice,proto3,enum=fetchai.group.v1alpha1.Choice" json:"choice,omitempty"`
	// metadata is any arbitrary metadata to attached to the vote.
	Metadata []byte `protobuf:"bytes,4,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// submitted_at is the timestamp when the vote was submitted.
	SubmittedAt types.Timestamp `protobuf:"bytes,5,opt,name=submitted_at,json=submittedAt,proto3" json:"submitted_at"`
}

func (m *Vote) Reset()         { *m = Vote{} }
func (m *Vote) String() string { return proto.CompactTextString(m) }
func (*Vote) ProtoMessage()    {}
func (*Vote) Descriptor() ([]byte, []int) {
	return fileDescriptor_35b2f87fd83fcfeb, []int{8}
}
func (m *Vote) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vote.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Vote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vote.Merge(m, src)
}
func (m *Vote) XXX_Size() int {
	return m.Size()
}
func (m *Vote) XXX_DiscardUnknown() {
	xxx_messageInfo_Vote.DiscardUnknown(m)
}

var xxx_messageInfo_Vote proto.InternalMessageInfo

func (m *Vote) GetProposalId() uint64 {
	if m != nil {
		return m.ProposalId
	}
	return 0
}

func (m *Vote) GetVoter() string {
	if m != nil {
		return m.Voter
	}
	return ""
}

func (m *Vote) GetChoice() Choice {
	if m != nil {
		return m.Choice
	}
	return Choice_CHOICE_UNSPECIFIED
}

func (m *Vote) GetMetadata() []byte {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Vote) GetSubmittedAt() types.Timestamp {
	if m != nil {
		return m.SubmittedAt
	}
	return types.Timestamp{}
}

type TallyPoll struct {
	Entries []*TallyPollEntry `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries,omitempty"`
}

func (m *TallyPoll) Reset()         { *m = TallyPoll{} }
func (m *TallyPoll) String() string { return proto.CompactTextString(m) }
func (*TallyPoll) ProtoMessage()    {}
func (*TallyPoll) Descriptor() ([]byte, []int) {
	return fileDescriptor_35b2f87fd83fcfeb, []int{9}
}
func (m *TallyPoll) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TallyPoll) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TallyPoll.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TallyPoll) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TallyPoll.Merge(m, src)
}
func (m *TallyPoll) XXX_Size() int {
	return m.Size()
}
func (m *TallyPoll) XXX_DiscardUnknown() {
	xxx_messageInfo_TallyPoll.DiscardUnknown(m)
}

var xxx_messageInfo_TallyPoll proto.InternalMessageInfo

type TallyPollEntry struct {
	OptionTitle string `protobuf:"bytes,1,opt,name=option_title,json=optionTitle,proto3" json:"option_title,omitempty"`
	Weight      string `protobuf:"bytes,2,opt,name=weight,proto3" json:"weight,omitempty"`
}

func (m *TallyPollEntry) Reset()         { *m = TallyPollEntry{} }
func (m *TallyPollEntry) String() string { return proto.CompactTextString(m) }
func (*TallyPollEntry) ProtoMessage()    {}
func (*TallyPollEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_35b2f87fd83fcfeb, []int{10}
}
func (m *TallyPollEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TallyPollEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TallyPollEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TallyPollEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TallyPollEntry.Merge(m, src)
}
func (m *TallyPollEntry) XXX_Size() int {
	return m.Size()
}
func (m *TallyPollEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_TallyPollEntry.DiscardUnknown(m)
}

var xxx_messageInfo_TallyPollEntry proto.InternalMessageInfo

// Options represents the choices voters can vote for a poll.
type Options struct {
	Titles []string `protobuf:"bytes,1,rep,name=titles,proto3" json:"titles,omitempty"`
}

func (m *Options) Reset()         { *m = Options{} }
func (m *Options) String() string { return proto.CompactTextString(m) }
func (*Options) ProtoMessage()    {}
func (*Options) Descriptor() ([]byte, []int) {
	return fileDescriptor_35b2f87fd83fcfeb, []int{11}
}
func (m *Options) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Options) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Options.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Options) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Options.Merge(m, src)
}
func (m *Options) XXX_Size() int {
	return m.Size()
}
func (m *Options) XXX_DiscardUnknown() {
	xxx_messageInfo_Options.DiscardUnknown(m)
}

var xxx_messageInfo_Options proto.InternalMessageInfo

// Poll defines a group poll. Any member of a group can submit a poll
// for a group to decide upon.
// The options in a poll can be customised by the creator.
type Poll struct {
	// poll_id is the unique id of the poll.
	PollId uint64 `protobuf:"varint,1,opt,name=poll_id,json=pollId,proto3" json:"poll_id,omitempty"`
	// group_id is the unique ID of the group.
	GroupId uint64 `protobuf:"varint,2,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	// title is the title of the poll.
	Title string `protobuf:"bytes,3,opt,name=title,proto3" json:"title,omitempty"`
	// options are the choices of the poll.
	Options Options `protobuf:"bytes,4,opt,name=options,proto3" json:"options"`
	// creator is the account address of the poll creator.
	Creator string `protobuf:"bytes,5,opt,name=creator,proto3" json:"creator,omitempty"`
	// vote_limit is the maximum number of options each voter can choose.
	VoteLimit int32 `protobuf:"varint,6,opt,name=vote_limit,json=voteLimit,proto3" json:"vote_limit,omitempty"`
	// vote_state contains the sums of all weighted votes for this poll.
	VoteState TallyPoll `protobuf:"bytes,7,opt,name=vote_state,json=voteState,proto3" json:"vote_state"`
	// metadata is any arbitrary metadata to attached to the poll.
	Metadata []byte `protobuf:"bytes,8,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// submitted_at is a timestamp specifying when a poll was submitted.
	SubmittedAt types.Timestamp `protobuf:"bytes,9,opt,name=submitted_at,json=submittedAt,proto3" json:"submitted_at"`
	// group_version tracks the version of the group that this poll corresponds to.
	// When group membership is changed, existing polls from previous group versions will become invalid.
	GroupVersion uint64 `protobuf:"varint,10,opt,name=group_version,json=groupVersion,proto3" json:"group_version,omitempty"`
	// Status represents the high level position in the life cycle of the poll. Initial value is Submitted.
	Status Poll_Status `protobuf:"varint,11,opt,name=status,proto3,enum=fetchai.group.v1alpha1.Poll_Status" json:"status,omitempty"`
	// timeout is the timestamp of the block where the poll times out. Header times of the votes
	// must be before this end time to be included in the election.
	Timeout types.Timestamp `protobuf:"bytes,12,opt,name=timeout,proto3" json:"timeout"`
}

func (m *Poll) Reset()         { *m = Poll{} }
func (m *Poll) String() string { return proto.CompactTextString(m) }
func (*Poll) ProtoMessage()    {}
func (*Poll) Descriptor() ([]byte, []int) {
	return fileDescriptor_35b2f87fd83fcfeb, []int{12}
}
func (m *Poll) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Poll) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Poll.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Poll) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Poll.Merge(m, src)
}
func (m *Poll) XXX_Size() int {
	return m.Size()
}
func (m *Poll) XXX_DiscardUnknown() {
	xxx_messageInfo_Poll.DiscardUnknown(m)
}

var xxx_messageInfo_Poll proto.InternalMessageInfo

// VotePoll represents a vote for a poll.
type VotePoll struct {
	// poll_id is the unique ID of the pool.
	PollId uint64 `protobuf:"varint,1,opt,name=poll_id,json=pollId,proto3" json:"poll_id,omitempty"`
	// voter is the account address of the voter.
	Voter string `protobuf:"bytes,2,opt,name=voter,proto3" json:"voter,omitempty"`
	// options are the voter's choices on the poll.
	Options Options `protobuf:"bytes,3,opt,name=options,proto3" json:"options"`
	// metadata is any arbitrary metadata to attached to the vote.
	Metadata []byte `protobuf:"bytes,4,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// submitted_at is the timestamp when the vote was submitted.
	SubmittedAt types.Timestamp `protobuf:"bytes,5,opt,name=submitted_at,json=submittedAt,proto3" json:"submitted_at"`
}

func (m *VotePoll) Reset()         { *m = VotePoll{} }
func (m *VotePoll) String() string { return proto.CompactTextString(m) }
func (*VotePoll) ProtoMessage()    {}
func (*VotePoll) Descriptor() ([]byte, []int) {
	return fileDescriptor_35b2f87fd83fcfeb, []int{13}
}
func (m *VotePoll) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VotePoll) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VotePoll.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VotePoll) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VotePoll.Merge(m, src)
}
func (m *VotePoll) XXX_Size() int {
	return m.Size()
}
func (m *VotePoll) XXX_DiscardUnknown() {
	xxx_messageInfo_VotePoll.DiscardUnknown(m)
}

var xxx_messageInfo_VotePoll proto.InternalMessageInfo

func (m *VotePoll) GetPollId() uint64 {
	if m != nil {
		return m.PollId
	}
	return 0
}

func (m *VotePoll) GetVoter() string {
	if m != nil {
		return m.Voter
	}
	return ""
}

func (m *VotePoll) GetOptions() Options {
	if m != nil {
		return m.Options
	}
	return Options{}
}

func (m *VotePoll) GetMetadata() []byte {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *VotePoll) GetSubmittedAt() types.Timestamp {
	if m != nil {
		return m.SubmittedAt
	}
	return types.Timestamp{}
}

func init() {
	proto.RegisterEnum("fetchai.group.v1alpha1.Choice", Choice_name, Choice_value)
	proto.RegisterEnum("fetchai.group.v1alpha1.Proposal_Status", Proposal_Status_name, Proposal_Status_value)
	proto.RegisterEnum("fetchai.group.v1alpha1.Proposal_Result", Proposal_Result_name, Proposal_Result_value)
	proto.RegisterEnum("fetchai.group.v1alpha1.Proposal_ExecutorResult", Proposal_ExecutorResult_name, Proposal_ExecutorResult_value)
	proto.RegisterEnum("fetchai.group.v1alpha1.Poll_Status", Poll_Status_name, Poll_Status_value)
	proto.RegisterType((*Member)(nil), "fetchai.group.v1alpha1.Member")
	proto.RegisterType((*Members)(nil), "fetchai.group.v1alpha1.Members")
	proto.RegisterType((*ThresholdDecisionPolicy)(nil), "fetchai.group.v1alpha1.ThresholdDecisionPolicy")
	proto.RegisterType((*GroupInfo)(nil), "fetchai.group.v1alpha1.GroupInfo")
	proto.RegisterType((*GroupMember)(nil), "fetchai.group.v1alpha1.GroupMember")
	proto.RegisterType((*GroupAccountInfo)(nil), "fetchai.group.v1alpha1.GroupAccountInfo")
	proto.RegisterType((*Proposal)(nil), "fetchai.group.v1alpha1.Proposal")
	proto.RegisterType((*Tally)(nil), "fetchai.group.v1alpha1.Tally")
	proto.RegisterType((*Vote)(nil), "fetchai.group.v1alpha1.Vote")
	proto.RegisterType((*TallyPoll)(nil), "fetchai.group.v1alpha1.TallyPoll")
	proto.RegisterType((*TallyPollEntry)(nil), "fetchai.group.v1alpha1.TallyPollEntry")
	proto.RegisterType((*Options)(nil), "fetchai.group.v1alpha1.Options")
	proto.RegisterType((*Poll)(nil), "fetchai.group.v1alpha1.Poll")
	proto.RegisterType((*VotePoll)(nil), "fetchai.group.v1alpha1.VotePoll")
}

func init() {
	proto.RegisterFile("fetchai/group/v1alpha1/types.proto", fileDescriptor_35b2f87fd83fcfeb)
}

var fileDescriptor_35b2f87fd83fcfeb = []byte{
	// 1578 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0x4f, 0x6f, 0x1b, 0x5b,
	0x15, 0xcf, 0xd8, 0x8e, 0xff, 0x1c, 0x27, 0x8e, 0xb9, 0x4d, 0x13, 0xc7, 0x6d, 0x9c, 0x89, 0x2b,
	0x68, 0x00, 0xc5, 0x56, 0x82, 0x40, 0x22, 0x15, 0x2d, 0xb6, 0x33, 0x01, 0x43, 0x1a, 0xa7, 0x63,
	0x3b, 0x94, 0x6e, 0xcc, 0x78, 0xe6, 0xc6, 0x19, 0x18, 0xcf, 0xb5, 0x66, 0xae, 0x43, 0xcd, 0x07,
	0x40, 0xc5, 0x2b, 0x76, 0x88, 0x85, 0xa5, 0x4a, 0x7c, 0x01, 0x16, 0x7c, 0x00, 0x96, 0x15, 0xab,
	0x8a, 0x05, 0x42, 0x45, 0x42, 0x4f, 0xed, 0xe6, 0x7d, 0x81, 0xb7, 0x7f, 0x9a, 0x7b, 0xef, 0xc4,
	0x9e, 0xc4, 0x76, 0xfa, 0x9e, 0xfa, 0x56, 0xf1, 0xb9, 0xf7, 0xfc, 0xce, 0x3d, 0xe7, 0x77, 0xce,
	0x9c, 0x73, 0x14, 0xc8, 0x9f, 0x63, 0xaa, 0x5f, 0x68, 0x66, 0xb1, 0xe3, 0x90, 0x7e, 0xaf, 0x78,
	0xb9, 0xa7, 0x59, 0xbd, 0x0b, 0x6d, 0xaf, 0x48, 0x07, 0x3d, 0xec, 0x16, 0x7a, 0x0e, 0xa1, 0x04,
	0xad, 0x09, 0x9d, 0x02, 0xd3, 0x29, 0xf8, 0x3a, 0xd9, 0xd5, 0x0e, 0xe9, 0x10, 0xa6, 0x52, 0xf4,
	0x7e, 0x71, 0xed, 0x6c, 0xae, 0x43, 0x48, 0xc7, 0xc2, 0x45, 0x26, 0xb5, 0xfb, 0xe7, 0x45, 0xa3,
	0xef, 0x68, 0xd4, 0x24, 0xb6, 0xb8, 0xdf, 0xba, 0x7e, 0x4f, 0xcd, 0x2e, 0x76, 0xa9, 0xd6, 0xed,
	0x09, 0x85, 0x0d, 0x9d, 0xb8, 0x5d, 0xe2, 0xb6, 0xb8, 0x65, 0x2e, 0xf8, 0x57, 0xd7, 0xb1, 0x9a,
	0x3d, 0xe0, 0x57, 0xf9, 0x33, 0x88, 0x3e, 0xc5, 0xdd, 0x36, 0x76, 0x50, 0x06, 0x62, 0x9a, 0x61,
	0x38, 0xd8, 0x75, 0x33, 0x92, 0x2c, 0xed, 0x24, 0x54, 0x5f, 0x44, 0x6b, 0x10, 0xfd, 0x3d, 0x36,
	0x3b, 0x17, 0x34, 0x13, 0x62, 0x17, 0x42, 0x42, 0x59, 0x88, 0x77, 0x31, 0xd5, 0x0c, 0x8d, 0x6a,
	0x99, 0xb0, 0x2c, 0xed, 0x2c, 0xa9, 0x57, 0x72, 0xbe, 0x0a, 0x31, 0x6e, 0xd7, 0x45, 0x8f, 0x21,
	0xd6, 0xe5, 0x3f, 0x33, 0x92, 0x1c, 0xde, 0x49, 0xee, 0xe7, 0x0a, 0xd3, 0x99, 0x29, 0x70, 0x44,
	0x39, 0xf2, 0xe6, 0xff, 0x5b, 0x0b, 0xaa, 0x0f, 0xca, 0xff, 0x51, 0x82, 0xf5, 0xc6, 0x85, 0x83,
	0xdd, 0x0b, 0x62, 0x19, 0x87, 0x58, 0x37, 0x5d, 0x93, 0xd8, 0xa7, 0xc4, 0x32, 0xf5, 0x01, 0xba,
	0x0f, 0x09, 0xea, 0x5f, 0x09, 0xb7, 0xc7, 0x07, 0xe8, 0xc7, 0x10, 0xf3, 0x58, 0x22, 0x7d, 0xee,
	0x79, 0x72, 0x7f, 0xa3, 0xc0, 0x99, 0x28, 0xf8, 0x4c, 0x14, 0x0e, 0x05, 0xcb, 0xfe, 0xa3, 0x42,
	0xff, 0x00, 0xfd, 0xfb, 0x1f, 0xbb, 0xa9, 0xe0, 0x63, 0xf9, 0xbf, 0x4b, 0x90, 0xf8, 0x99, 0xe7,
	0x71, 0xd5, 0x3e, 0x27, 0x68, 0x03, 0xe2, 0xcc, 0xfd, 0x96, 0xc9, 0x5f, 0x8e, 0xa8, 0x31, 0x26,
	0x57, 0x0d, 0xb4, 0x0a, 0x8b, 0x9a, 0xd1, 0x35, 0x6d, 0xc1, 0x17, 0x17, 0xe6, 0xd1, 0xe5, 0x91,
	0x7f, 0x89, 0x1d, 0xef, 0xad, 0x4c, 0x84, 0xdb, 0x12, 0x22, 0xda, 0x86, 0x25, 0x4a, 0xa8, 0x66,
	0xb5, 0x44, 0x0a, 0x16, 0x99, 0xc9, 0x24, 0x3b, 0xfb, 0x15, 0xcf, 0xc3, 0x06, 0xc4, 0xdb, 0x96,
	0xdb, 0x22, 0xb6, 0x35, 0xc8, 0x44, 0x65, 0x69, 0x27, 0xae, 0xc6, 0xda, 0x96, 0x5b, 0xb3, 0xad,
	0x41, 0xfe, 0x37, 0x90, 0x64, 0x1e, 0x8b, 0x1c, 0xcf, 0xf1, 0xf9, 0x47, 0x10, 0xe5, 0x84, 0x0b,
	0xaa, 0x6e, 0x49, 0x92, 0x2a, 0xb4, 0xf3, 0x7f, 0x09, 0x41, 0x9a, 0x3d, 0x51, 0xd2, 0x75, 0xd2,
	0xb7, 0x29, 0xe3, 0x66, 0x76, 0x2d, 0x4d, 0x7a, 0x10, 0x9a, 0xc1, 0x5a, 0x78, 0x16, 0x6b, 0x91,
	0xd9, 0xac, 0x2d, 0x06, 0x59, 0x7b, 0x06, 0x2b, 0x86, 0x48, 0x5e, 0xab, 0xc7, 0xb2, 0xc7, 0x98,
	0x49, 0xee, 0xaf, 0xde, 0xa8, 0x80, 0x92, 0x3d, 0x28, 0xa3, 0x7f, 0xdd, 0xc8, 0xb6, 0x9a, 0x32,
	0x82, 0xa5, 0xf6, 0x6d, 0x48, 0x19, 0xd8, 0x31, 0x2f, 0x59, 0xb9, 0xb4, 0x7e, 0x87, 0x07, 0x99,
	0x18, 0x73, 0x67, 0x79, 0x7c, 0xfa, 0x4b, 0x3c, 0x38, 0x88, 0xbf, 0x7a, 0xbd, 0xb5, 0xf0, 0xf9,
	0xeb, 0x2d, 0x29, 0xff, 0x05, 0x40, 0xfc, 0xd4, 0x21, 0x3d, 0xe2, 0x6a, 0x16, 0xda, 0x82, 0x64,
	0x4f, 0xfc, 0x1e, 0x93, 0x0f, 0xfe, 0x51, 0xd5, 0x98, 0xa4, 0x2c, 0x14, 0xa4, 0x6c, 0x5e, 0xdd,
	0xdc, 0x87, 0x04, 0xb7, 0xe1, 0x7d, 0x5d, 0x11, 0x39, 0xec, 0xd5, 0xff, 0xd5, 0x01, 0xaa, 0xc0,
	0x92, 0xdb, 0x6f, 0x77, 0x4d, 0x4a, 0xb1, 0xd1, 0xd2, 0x78, 0xed, 0x24, 0xf7, 0xb3, 0x37, 0x28,
	0x68, 0xf8, 0xad, 0x44, 0x7c, 0x05, 0xc9, 0x2b, 0x54, 0x89, 0xa2, 0x07, 0xb0, 0xcc, 0x33, 0xe6,
	0x53, 0x1d, 0x65, 0xbe, 0x2f, 0xb1, 0xc3, 0x33, 0xc1, 0xf7, 0x3e, 0xdc, 0xe5, 0x4a, 0x1a, 0xaf,
	0x82, 0x2b, 0xe5, 0x18, 0x53, 0xbe, 0xd3, 0x99, 0xa8, 0x10, 0x1f, 0xf3, 0x04, 0xa2, 0x2e, 0xd5,
	0x68, 0xdf, 0xcd, 0xc4, 0x65, 0x69, 0x27, 0xb5, 0xff, 0x70, 0x56, 0xc5, 0xf9, 0x24, 0x16, 0xea,
	0x4c, 0x5d, 0x15, 0x30, 0xcf, 0x80, 0x83, 0xdd, 0xbe, 0x45, 0x33, 0x89, 0x8f, 0x34, 0xa0, 0x32,
	0x75, 0x55, 0xc0, 0x50, 0x19, 0xe0, 0x92, 0x50, 0xdc, 0xf2, 0xec, 0xe1, 0x0c, 0x30, 0x76, 0x36,
	0x67, 0x19, 0x69, 0x68, 0x96, 0x35, 0x10, 0x04, 0x25, 0x3c, 0x98, 0xe7, 0x0d, 0x46, 0x07, 0xe3,
	0x1e, 0x93, 0xfc, 0x48, 0x7a, 0x7d, 0x00, 0x7a, 0x0e, 0x2b, 0xf8, 0x25, 0xd6, 0xfb, 0x94, 0x38,
	0x2d, 0x11, 0xc9, 0x12, 0x8b, 0xa4, 0x78, 0x6b, 0x24, 0x8a, 0xc0, 0x89, 0x88, 0x52, 0x38, 0x20,
	0xa3, 0x1d, 0x88, 0x74, 0xdd, 0x8e, 0x9b, 0x59, 0x66, 0x0d, 0x77, 0x6a, 0xd1, 0xab, 0x4c, 0x23,
	0xff, 0x56, 0x82, 0x28, 0xe7, 0x15, 0xed, 0x01, 0xaa, 0x37, 0x4a, 0x8d, 0x66, 0xbd, 0xd5, 0x3c,
	0xa9, 0x9f, 0x2a, 0x95, 0xea, 0x51, 0x55, 0x39, 0x4c, 0x2f, 0x64, 0x37, 0x86, 0x23, 0xf9, 0xae,
	0xff, 0x32, 0xd7, 0xad, 0xda, 0x97, 0x9a, 0x65, 0x1a, 0x68, 0x0f, 0xd2, 0x02, 0x52, 0x6f, 0x96,
	0x9f, 0x56, 0x1b, 0x0d, 0xe5, 0x30, 0x2d, 0x65, 0xef, 0x0d, 0x47, 0xf2, 0x7a, 0x10, 0x50, 0xf7,
	0x2b, 0x0a, 0x7d, 0x1f, 0x96, 0x05, 0xa4, 0x72, 0x5c, 0xab, 0x2b, 0x87, 0xe9, 0x50, 0x36, 0x33,
	0x1c, 0xc9, 0xab, 0x41, 0xfd, 0x8a, 0x45, 0x5c, 0x6c, 0xa0, 0x5d, 0x48, 0x09, 0xe5, 0x52, 0xb9,
	0xa6, 0x7a, 0xd6, 0xc3, 0xd3, 0xdc, 0x29, 0xb5, 0x89, 0x43, 0xb1, 0x91, 0x8d, 0xbc, 0xfa, 0x5b,
	0x6e, 0x21, 0xff, 0x4e, 0x82, 0xa8, 0xe0, 0x61, 0x0f, 0x90, 0xaa, 0xd4, 0x9b, 0xc7, 0x8d, 0x79,
	0x21, 0x71, 0x5d, 0x3f, 0xa4, 0x1f, 0x4e, 0x40, 0x8e, 0xaa, 0x27, 0xa5, 0xe3, 0xea, 0x0b, 0x16,
	0xd4, 0xe6, 0x70, 0x24, 0x6f, 0x04, 0x21, 0x4d, 0xfb, 0xdc, 0xb4, 0x35, 0xcb, 0xfc, 0x03, 0x36,
	0x50, 0x11, 0x56, 0x04, 0xac, 0x54, 0xa9, 0x28, 0xa7, 0x0d, 0x16, 0x58, 0x76, 0x38, 0x92, 0xd7,
	0x82, 0x98, 0x92, 0xae, 0xe3, 0x1e, 0x0d, 0x00, 0x54, 0xe5, 0x17, 0x4a, 0x85, 0xc7, 0x36, 0x05,
	0xa0, 0xe2, 0xdf, 0x62, 0x7d, 0x1c, 0xdc, 0x5f, 0x43, 0x90, 0x0a, 0x26, 0x1f, 0x95, 0xe1, 0x9e,
	0xf2, 0x5c, 0xa9, 0x34, 0x1b, 0x35, 0xb5, 0x35, 0x35, 0xda, 0xed, 0xe1, 0x48, 0xde, 0xf4, 0xad,
	0x06, 0xc1, 0x7e, 0xd4, 0x3f, 0x81, 0xf5, 0xeb, 0x36, 0x4e, 0x6a, 0x8d, 0x96, 0xda, 0x3c, 0x49,
	0x4b, 0x59, 0x79, 0x38, 0x92, 0xef, 0x4f, 0xc7, 0x9f, 0x10, 0xaa, 0xf6, 0x6d, 0xf4, 0xf8, 0x26,
	0xbc, 0xde, 0xac, 0x54, 0x94, 0x7a, 0x3d, 0x1d, 0x9a, 0xf7, 0x7c, 0xbd, 0xaf, 0xeb, 0x5e, 0x8f,
	0x9b, 0x82, 0x3f, 0x2a, 0x55, 0x8f, 0x9b, 0xaa, 0x92, 0x0e, 0xcf, 0xc3, 0x1f, 0x69, 0xa6, 0xd5,
	0x77, 0x30, 0xe7, 0xe6, 0x20, 0xe2, 0xf5, 0xde, 0xfc, 0x9f, 0x24, 0x58, 0x64, 0x1f, 0x2b, 0xba,
	0x07, 0x89, 0x01, 0x76, 0x5b, 0xac, 0xeb, 0x88, 0x41, 0x14, 0x1f, 0x60, 0xb7, 0xe2, 0xc9, 0xde,
	0x24, 0xb2, 0x89, 0xb8, 0x13, 0x1d, 0xd7, 0x26, 0xfc, 0xea, 0x01, 0x2c, 0x6b, 0x6d, 0x97, 0x6a,
	0xa6, 0x2d, 0xee, 0xf9, 0x44, 0x5a, 0x12, 0x87, 0x5c, 0x69, 0x13, 0xe0, 0x12, 0x53, 0xdf, 0x42,
	0x84, 0xef, 0x1e, 0xde, 0x09, 0xbb, 0x16, 0xbe, 0xfc, 0x47, 0x82, 0xc8, 0x19, 0xa1, 0xf8, 0xf6,
	0xfe, 0xbf, 0x0a, 0x8b, 0x5e, 0x53, 0x71, 0xfc, 0x9d, 0x81, 0x09, 0xde, 0x54, 0xd6, 0x2f, 0x88,
	0xa9, 0x63, 0xe6, 0x42, 0x6a, 0xf6, 0x54, 0xae, 0x30, 0x2d, 0x55, 0x68, 0xcf, 0x9d, 0x9a, 0x9f,
	0x62, 0x2a, 0xe4, 0xeb, 0x90, 0x60, 0x1c, 0x9f, 0x12, 0xcb, 0x42, 0x3f, 0x85, 0x18, 0xb6, 0xa9,
	0x63, 0x62, 0x7f, 0xc3, 0xfb, 0xce, 0xdc, 0x26, 0xea, 0x61, 0x14, 0x9b, 0x3a, 0x03, 0xd5, 0x87,
	0x09, 0xb6, 0x9e, 0x41, 0x2a, 0xa8, 0xe0, 0x6d, 0x3f, 0xa4, 0xc7, 0x06, 0x2e, 0x35, 0xa9, 0x85,
	0x45, 0x12, 0x93, 0xfc, 0xac, 0xe1, 0x1d, 0xcd, 0xda, 0x4e, 0x85, 0xc9, 0x87, 0x10, 0xab, 0x31,
	0x65, 0xb6, 0xc6, 0x32, 0x23, 0xdc, 0xc9, 0x84, 0x2a, 0x24, 0xa1, 0xf8, 0x6e, 0x11, 0x22, 0x2c,
	0x98, 0x75, 0x88, 0xf5, 0x88, 0x35, 0x91, 0xa5, 0xa8, 0x27, 0x56, 0x8d, 0x5b, 0x56, 0x17, 0xee,
	0x9f, 0x58, 0x5d, 0x98, 0x80, 0x9e, 0x40, 0x8c, 0x3b, 0xea, 0xb2, 0x1c, 0x24, 0xf7, 0xb7, 0x66,
	0xd1, 0x22, 0x5c, 0xf4, 0xe7, 0x83, 0x40, 0x79, 0x3b, 0x81, 0xee, 0x60, 0x8d, 0x12, 0x47, 0xac,
	0x7d, 0xbe, 0xc8, 0x8a, 0xcf, 0x9b, 0x5c, 0x96, 0xd9, 0x35, 0x29, 0x9b, 0xc8, 0x8b, 0x7c, 0x28,
	0x1d, 0x7b, 0x07, 0xe8, 0x28, 0x30, 0xd8, 0x62, 0xec, 0xf1, 0xed, 0x5b, 0x73, 0x72, 0x73, 0xb8,
	0x4d, 0x96, 0x51, 0xfc, 0x96, 0x32, 0x4a, 0x7c, 0x92, 0xe5, 0x02, 0xa6, 0x2c, 0x17, 0x8f, 0xae,
	0x16, 0x85, 0x24, 0xfb, 0x08, 0x1e, 0xcc, 0x9c, 0x8e, 0xc4, 0xba, 0xb1, 0x24, 0x4c, 0xcc, 0xe7,
	0xa5, 0xaf, 0x38, 0x9f, 0xf3, 0xff, 0x1c, 0xcf, 0xc6, 0xdd, 0x19, 0xb3, 0xf1, 0xee, 0x70, 0x24,
	0x7f, 0xcb, 0x7b, 0x37, 0x38, 0x17, 0x77, 0xa7, 0xce, 0xc5, 0xf5, 0xe1, 0x48, 0xbe, 0x33, 0x56,
	0x1e, 0xcf, 0xc4, 0x87, 0x37, 0x67, 0xe2, 0xea, 0x70, 0x24, 0xa7, 0xc7, 0xba, 0x62, 0x1e, 0x7e,
	0x77, 0xca, 0x3c, 0xbc, 0xe6, 0x42, 0x60, 0x16, 0x8a, 0xe2, 0xfe, 0x9f, 0x04, 0x71, 0xaf, 0x0d,
	0xcd, 0x2f, 0xf0, 0xe9, 0x2d, 0x68, 0xa2, 0x8a, 0xc3, 0x5f, 0xab, 0x8a, 0xbf, 0xe9, 0x5e, 0xf4,
	0x3d, 0x03, 0xa2, 0xbc, 0xfd, 0xa1, 0x35, 0x40, 0x95, 0x9f, 0xd7, 0xaa, 0x15, 0x25, 0x98, 0x25,
	0xb4, 0x0c, 0x09, 0x71, 0x7e, 0x52, 0x4b, 0x4b, 0x28, 0x05, 0x20, 0xc4, 0x5f, 0x2b, 0xf5, 0x74,
	0x08, 0x21, 0x48, 0x09, 0xb9, 0x54, 0xae, 0x37, 0x4a, 0xd5, 0x93, 0x74, 0x18, 0xad, 0x40, 0x52,
	0x9c, 0x9d, 0x29, 0x8d, 0x5a, 0x3a, 0x52, 0x7e, 0xf4, 0xe6, 0x7d, 0x4e, 0x7a, 0xfb, 0x3e, 0x27,
	0x7d, 0xf6, 0x3e, 0x27, 0xfd, 0xf9, 0x43, 0x6e, 0xe1, 0xed, 0x87, 0xdc, 0xc2, 0x7f, 0x3f, 0xe4,
	0x16, 0x5e, 0x6c, 0x77, 0x4c, 0x7a, 0xd1, 0x6f, 0x17, 0x74, 0xd2, 0x2d, 0xfa, 0xff, 0x17, 0x60,
	0x7f, 0x8d, 0xe2, 0x4b, 0xfe, 0x0f, 0x82, 0x76, 0x94, 0x45, 0xf2, 0x83, 0x2f, 0x03, 0x00, 0x00,
	0xff, 0xff, 0x10, 0x66, 0x0f, 0x2e, 0x38, 0x10, 0x00, 0x00,
}

func (this *GroupAccountInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GroupAccountInfo)
	if !ok {
		that2, ok := that.(GroupAccountInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.GroupId != that1.GroupId {
		return false
	}
	if this.Admin != that1.Admin {
		return false
	}
	if !bytes.Equal(this.Metadata, that1.Metadata) {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if !this.DecisionPolicy.Equal(that1.DecisionPolicy) {
		return false
	}
	if !bytes.Equal(this.DerivationKey, that1.DerivationKey) {
		return false
	}
	return true
}
func (m *Member) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Member) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Member) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Weight) > 0 {
		i -= len(m.Weight)
		copy(dAtA[i:], m.Weight)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Weight)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Members) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Members) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Members) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Members) > 0 {
		for iNdEx := len(m.Members) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Members[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ThresholdDecisionPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ThresholdDecisionPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ThresholdDecisionPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Timeout.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Threshold) > 0 {
		i -= len(m.Threshold)
		copy(dAtA[i:], m.Threshold)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Threshold)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GroupInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlsOnly {
		i--
		if m.BlsOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.TotalWeight) > 0 {
		i -= len(m.TotalWeight)
		copy(dAtA[i:], m.TotalWeight)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TotalWeight)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Version != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0x12
	}
	if m.GroupId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GroupMember) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupMember) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupMember) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Member != nil {
		{
			size, err := m.Member.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.GroupId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GroupAccountInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupAccountInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupAccountInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DerivationKey) > 0 {
		i -= len(m.DerivationKey)
		copy(dAtA[i:], m.DerivationKey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DerivationKey)))
		i--
		dAtA[i] = 0x3a
	}
	if m.DecisionPolicy != nil {
		{
			size, err := m.DecisionPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Version != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0x1a
	}
	if m.GroupId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Proposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Proposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Proposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msgs) > 0 {
		for iNdEx := len(m.Msgs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Msgs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if m.ExecutorResult != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ExecutorResult))
		i--
		dAtA[i] = 0x60
	}
	{
		size, err := m.Timeout.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	{
		size, err := m.VoteState.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	if m.Result != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Result))
		i--
		dAtA[i] = 0x48
	}
	if m.Status != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x40
	}
	if m.GroupAccountVersion != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.GroupAccountVersion))
		i--
		dAtA[i] = 0x38
	}
	if m.GroupVersion != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.GroupVersion))
		i--
		dAtA[i] = 0x30
	}
	{
		size, err := m.SubmittedAt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.Proposers) > 0 {
		for iNdEx := len(m.Proposers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Proposers[iNdEx])
			copy(dAtA[i:], m.Proposers[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Proposers[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if m.ProposalId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ProposalId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Tally) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tally) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tally) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VetoCount) > 0 {
		i -= len(m.VetoCount)
		copy(dAtA[i:], m.VetoCount)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VetoCount)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AbstainCount) > 0 {
		i -= len(m.AbstainCount)
		copy(dAtA[i:], m.AbstainCount)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AbstainCount)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.NoCount) > 0 {
		i -= len(m.NoCount)
		copy(dAtA[i:], m.NoCount)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NoCount)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.YesCount) > 0 {
		i -= len(m.YesCount)
		copy(dAtA[i:], m.YesCount)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.YesCount)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Vote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Vote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.SubmittedAt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x22
	}
	if m.Choice != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Choice))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Voter) > 0 {
		i -= len(m.Voter)
		copy(dAtA[i:], m.Voter)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Voter)))
		i--
		dAtA[i] = 0x12
	}
	if m.ProposalId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ProposalId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TallyPoll) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TallyPoll) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TallyPoll) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for iNdEx := len(m.Entries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TallyPollEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TallyPollEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TallyPollEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Weight) > 0 {
		i -= len(m.Weight)
		copy(dAtA[i:], m.Weight)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Weight)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OptionTitle) > 0 {
		i -= len(m.OptionTitle)
		copy(dAtA[i:], m.OptionTitle)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OptionTitle)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Options) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Options) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Options) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Titles) > 0 {
		for iNdEx := len(m.Titles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Titles[iNdEx])
			copy(dAtA[i:], m.Titles[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Titles[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Poll) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Poll) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Poll) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Timeout.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	if m.Status != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x58
	}
	if m.GroupVersion != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.GroupVersion))
		i--
		dAtA[i] = 0x50
	}
	{
		size, err := m.SubmittedAt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x42
	}
	{
		size, err := m.VoteState.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if m.VoteLimit != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.VoteLimit))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0x2a
	}
	{
		size, err := m.Options.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x1a
	}
	if m.GroupId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x10
	}
	if m.PollId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PollId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VotePoll) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VotePoll) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VotePoll) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.SubmittedAt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.Options.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Voter) > 0 {
		i -= len(m.Voter)
		copy(dAtA[i:], m.Voter)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Voter)))
		i--
		dAtA[i] = 0x12
	}
	if m.PollId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PollId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Member) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Weight)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Members) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *ThresholdDecisionPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Threshold)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Timeout.Size()
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func (m *GroupInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovTypes(uint64(m.GroupId))
	}
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovTypes(uint64(m.Version))
	}
	l = len(m.TotalWeight)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.BlsOnly {
		n += 2
	}
	return n
}

func (m *GroupMember) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovTypes(uint64(m.GroupId))
	}
	if m.Member != nil {
		l = m.Member.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GroupAccountInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.GroupId != 0 {
		n += 1 + sovTypes(uint64(m.GroupId))
	}
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovTypes(uint64(m.Version))
	}
	if m.DecisionPolicy != nil {
		l = m.DecisionPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.DerivationKey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Proposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalId != 0 {
		n += 1 + sovTypes(uint64(m.ProposalId))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Proposers) > 0 {
		for _, s := range m.Proposers {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = m.SubmittedAt.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.GroupVersion != 0 {
		n += 1 + sovTypes(uint64(m.GroupVersion))
	}
	if m.GroupAccountVersion != 0 {
		n += 1 + sovTypes(uint64(m.GroupAccountVersion))
	}
	if m.Status != 0 {
		n += 1 + sovTypes(uint64(m.Status))
	}
	if m.Result != 0 {
		n += 1 + sovTypes(uint64(m.Result))
	}
	l = m.VoteState.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Timeout.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.ExecutorResult != 0 {
		n += 1 + sovTypes(uint64(m.ExecutorResult))
	}
	if len(m.Msgs) > 0 {
		for _, e := range m.Msgs {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *Tally) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.YesCount)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.NoCount)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AbstainCount)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.VetoCount)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Vote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalId != 0 {
		n += 1 + sovTypes(uint64(m.ProposalId))
	}
	l = len(m.Voter)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Choice != 0 {
		n += 1 + sovTypes(uint64(m.Choice))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.SubmittedAt.Size()
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func (m *TallyPoll) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *TallyPollEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OptionTitle)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Weight)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Options) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Titles) > 0 {
		for _, s := range m.Titles {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *Poll) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PollId != 0 {
		n += 1 + sovTypes(uint64(m.PollId))
	}
	if m.GroupId != 0 {
		n += 1 + sovTypes(uint64(m.GroupId))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Options.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.VoteLimit != 0 {
		n += 1 + sovTypes(uint64(m.VoteLimit))
	}
	l = m.VoteState.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.SubmittedAt.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.GroupVersion != 0 {
		n += 1 + sovTypes(uint64(m.GroupVersion))
	}
	if m.Status != 0 {
		n += 1 + sovTypes(uint64(m.Status))
	}
	l = m.Timeout.Size()
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func (m *VotePoll) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PollId != 0 {
		n += 1 + sovTypes(uint64(m.PollId))
	}
	l = len(m.Voter)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Options.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.SubmittedAt.Size()
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Member) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Member: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Member: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Weight = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = append(m.Metadata[:0], dAtA[iNdEx:postIndex]...)
			if m.Metadata == nil {
				m.Metadata = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Members) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Members: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Members: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, Member{})
			if err := m.Members[len(m.Members)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ThresholdDecisionPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ThresholdDecisionPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ThresholdDecisionPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Threshold = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = append(m.Metadata[:0], dAtA[iNdEx:postIndex]...)
			if m.Metadata == nil {
				m.Metadata = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalWeight", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalWeight = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlsOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BlsOnly = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupMember) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupMember: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupMember: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Member", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Member == nil {
				m.Member = &Member{}
			}
			if err := m.Member.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupAccountInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupAccountInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupAccountInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = append(m.Metadata[:0], dAtA[iNdEx:postIndex]...)
			if m.Metadata == nil {
				m.Metadata = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecisionPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DecisionPolicy == nil {
				m.DecisionPolicy = &types1.Any{}
			}
			if err := m.DecisionPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DerivationKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DerivationKey = append(m.DerivationKey[:0], dAtA[iNdEx:postIndex]...)
			if m.DerivationKey == nil {
				m.DerivationKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Proposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Proposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Proposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			m.ProposalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = append(m.Metadata[:0], dAtA[iNdEx:postIndex]...)
			if m.Metadata == nil {
				m.Metadata = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proposers = append(m.Proposers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmittedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SubmittedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupVersion", wireType)
			}
			m.GroupVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupAccountVersion", wireType)
			}
			m.GroupAccountVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupAccountVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Proposal_Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= Proposal_Result(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoteState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.VoteState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutorResult", wireType)
			}
			m.ExecutorResult = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExecutorResult |= Proposal_ExecutorResult(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msgs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msgs = append(m.Msgs, &types1.Any{})
			if err := m.Msgs[len(m.Msgs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tally) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tally: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tally: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field YesCount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.YesCount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoCount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NoCount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbstainCount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AbstainCount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VetoCount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VetoCount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			m.ProposalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Voter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Choice", wireType)
			}
			m.Choice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Choice |= Choice(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = append(m.Metadata[:0], dAtA[iNdEx:postIndex]...)
			if m.Metadata == nil {
				m.Metadata = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmittedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SubmittedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TallyPoll) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TallyPoll: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TallyPoll: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &TallyPollEntry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TallyPollEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TallyPollEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TallyPollEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionTitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Weight = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Options) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Options: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Options: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Titles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Titles = append(m.Titles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Poll) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Poll: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Poll: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PollId", wireType)
			}
			m.PollId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PollId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoteLimit", wireType)
			}
			m.VoteLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VoteLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoteState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.VoteState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = append(m.Metadata[:0], dAtA[iNdEx:postIndex]...)
			if m.Metadata == nil {
				m.Metadata = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmittedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SubmittedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupVersion", wireType)
			}
			m.GroupVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Poll_Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VotePoll) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VotePoll: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VotePoll: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PollId", wireType)
			}
			m.PollId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PollId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Voter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = append(m.Metadata[:0], dAtA[iNdEx:postIndex]...)
			if m.Metadata == nil {
				m.Metadata = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmittedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SubmittedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
